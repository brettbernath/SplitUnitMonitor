/**
 * @file embx_ir_rx_phy.h
 * @date 10/24/2018
 * @author: bbernath
 * @copyright Copyright (C) 2018 Brett Bernath. All Rights Reserved.
 */ 

#ifndef EMBX_IR_RX_PHY_H_
#define EMBX_IR_RX_PHY_H_

#include "embx/embx_ir/embx_ir_common.h"
#include "embx/embx_ir/embx_ir_rx_buffer.h"

/**
* @brief Define the timer counter used by the module.
*/
#define TC_IR_RX_PHY_MODULE					TC5

/** @brief The TC uses the 8 MHz input GCLK divided by the prescaler as it's clock */
#define EMBX_IR_RX_PHY_PRESCALER			TC_CLOCK_PRESCALER_DIV64 /** Selected to give 125 kHz or 8 us per tick */
#define EMBX_IR_RX_PHY_DIV_FACTOR			(64)
#define EMBX_IR_RX_PHY_CLK_FREQ				(EMBX_IR_MODULATOR_GCLK / EMBX_IR_RX_PHY_DIV_FACTOR) /* 8000000 / 64 = 125 kHz */
#define EMBX_IR_RX_PHY_USEC_PER_TICK		(8)   /* 64 / 8000000 */

/** 
* @brief enumerates the number of timer ticks per ms 
* @details The maximum number of ticks is 0xFFFF for a 16-bit timer so the maximum time given 8 us per tick is 524.28 ms.
*/
typedef enum {
	TICKS_1_ms =  (1 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */			
	TICKS_2_ms =  (2 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */			
	TICKS_3_ms =  (3 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */			
	TICKS_4_ms =  (4 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */			
	TICKS_5_ms =  (5 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */		
	TICKS_10_ms = (10 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */	
	TICKS_15_ms = (15 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */	
	TICKS_20_ms = (20 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */
	TICKS_25_ms = (25 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */
	TICKS_50_ms = (50 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */
	TICKS_100_ms = (100 * 1000) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */		
	TICKS_MAX_us = (524280) / EMBX_IR_RX_PHY_USEC_PER_TICK, /* ticks =  ms / us per tick */
} embx_ir_rx_phy_timeout_t;

/** @brief The time spent waiting without a GPIO event before entering the IDLE state.  This ensures that the line is idle. */
#define EMBX_IR_RX_PHY_SYNC_DELAY					(TICKS_20_ms)
/** @brief The timer used to measure the duration of a MARK overflows at this time. */
#define EMBX_IR_RX_PHY_MARK_DELAY					(TICKS_100_ms) 
/** @brief The timer used to measure the duration of a SPACE overflows at this time. */
#define EMBX_IR_RX_PHY_SPACE_DELAY					(TICKS_100_ms)
/** 
* @brief Allowable number of timer overflows (interrupts) allowed before a STATUS_ERR_TIMEOUT is generated, 
* @details A mark should complete before an overflow occurs so the typical number should be 0.  Set MARK_DELAY to a large
* enough value.  
* The time before a STATUS_ERR is generated is: MARK_DELAY * OVERFLOWS_MARK 
*/
#define EMBX_IR_RX_PHY_TIMER_OVERFLOWS_MARK			(4) 
 /** @brief Allowable number of timer overflows before a IR reception is declared complete.
 * @details   SPACE_DELAY * OVERFLOWS_SPACE */
#define EMBX_IR_RX_PHY_TIMER_OVERFLOWS_SPACE		(50)

/**  @brief Enumerates the states in the IR Rx Phy State Machine */
typedef enum {
	EMBX_IR_RX_PHY_STATE_SYNCRONIZE, /* The initial state of the PHY, unsure of the state of the line so wait for SPACE for longer than SYNCRONIZATION_TIME */
	EMBX_IR_RX_PHY_STATE_IDLE, /* Nothing is happening on the line, SPACE is the default level, waiting for first MARK of a transmission */
	EMBX_IR_RX_PHY_STATE_MARKING, /* Transmission MARK, the MARK period is timed */
	EMBX_IR_RX_PHY_STATE_SPACING, /* Transmission SPACE, the SPACE period is timed, if the SPACE time is longer than the TRANSMISSION_COMPLETE_TIME, the transmission is over and the LINE is IDLE */
} embx_ir_rx_phy_state_t;

/** @brief Enumeration of the input events to the IR Rx Phy State Machine */
typedef enum {
	EMBX_IR_RX_GPIO_EVENT_FALLING_EDGE, /** Generated by the GPIO on a falling edge from the IR receiver */
	EMBX_IR_RX_GPIO_EVENT_RISING_EDGE, /** Generated by the GPIO on a falling edge from the IR receiver */
	EMBX_IR_RX_TIMER_EVENT_TIMEOUT, /** Generated by the timer when the counter value is > the DELAY value */
} embx_ir_rx_event_t;

/**
* @brief Counts the timer overflows that occur in either the IDLE, MARKING, or SPACING state.
* @details Each state handles timer overflows differently.  
*    IDLE - timeouts should not occur because the timer should be stopped.  timer_overflow.idle > 0 is an error, the timer is running when it should be off. 
*    MARKING - 
*/
typedef struct {
	uint32_t idle;
	uint32_t mark;
	uint32_t space;
} embx_ir_rx_phy_timer_overflows_t ;

/**
* @brief Contains various statistics
*/
typedef struct {
	uint32_t resyncs; /** The state machine callls the resync handler when an error occurs */
	uint32_t buffer_overflows;
} embx_ir_rx_phy_stats_t;

/** @brief Stops the Timer and resets the counter to 0  */
extern void embx_ir_rx_phy_stop_timer(void);
/** @brief - Stops (clears the counter) then Starts the counter. */
extern void embx_ir_rx_phy_start_timer(embx_ir_rx_phy_timeout_t overflow);
/** @brief - Restarts the counter without stopping it first. */
extern void embx_ir_rx_phy_restart_timer(embx_ir_rx_phy_timeout_t overflow);
/** @brief Call to initialize when the RxPhy at the beginning of time or after a reset.
*  @details Initializes HW from a power on condition. */
extern void embx_ir_rx_phy_init(void);
/** @brief Resets the TC hardware to the default state, like power-on */
extern void embx_ir_rx_phy_reset(void);
/** @brief Turn the module on after it has been initialized or disabled. */
extern void embx_ir_rx_phy_enable(void);
/** @brief Turn the module off after it has been enableed. Does not reset hardware to defaults. */
extern void embx_ir_rx_phy_disable(void);
/** @brief Handles the rx phy state machine logic 
    @params embx_ir_rx_event_t - an event that is handled based upon the current state. */
extern void embx_rx_ir_phy_state_machine(embx_ir_rx_event_t event);
/** For testing ... */
extern void embx_ir_rx_phy_tb(void);

#endif /* EMBX_IR_RX_PHY_H_ */